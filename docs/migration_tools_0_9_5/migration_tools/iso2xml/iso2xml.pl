#!/usr/bin/perl -w


# $Id: iso2xml.pl, v 0.95 2008/03/24 03:26:42 arensb Exp $

# Copyright 2007-2008 Serhij Dubyk (serhijdubyk@gmail.com)
#
# At this time it's not part of some package.
#
# Script iso2xml.pl is free software; you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# Script iso2xml.pl is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

# Cnahges:
# 0.95 - repared bug on norepeating fields (serious)

#use Encode;
use bytes;
#use Data::Dump qw(dump);

#my $input_file_encoding="cp866";  # used for debug output
#my $input_file_encoding="utf-8"; # used for debug output

#my $RECORD_DELIMETER = '\x1d';		# IS3 : record end (?); record delimeter   (LIBER MEDIA,)
#my $RECORD_DELIMETER = '##';		# IS3 : record end (?); record delimeter   (ISIS)
my $flag_use_subfield_identifier_length=0; # 0|1   often this variable in leader are bad (for 0 use $default_subfield_identifier_length)
my $default_subfield_identifier_length=3;
#my $output_encoding="utf-8";  	  # used for debug output
my $flag_tray_correct_field_offset=1; # 1=do it automatically 
my @subfields_delimiter_variants=('\x1f','\^'); # will search for this delimeters
my $subfields_delimiter=''; # founded delimeter will be here
my $fields_delimiter;  # founded delimeter will be here
my $records_delimeter; # founded delimeter will be here
my %control_tags=(('001','0'),('005','0'));

if($ENV{'QUERY_STRING'})
   {($iso_file)=split(/\?/,$ENV{'QUERY_STRING'},1);}
else
   {$iso_file=$ARGV[0];}

unless($iso_file)
   {print "Error: input iso file ommited!\n";exit;}

print "Input iso-file: $iso_file\n";

#  &#1050;&#1072;&#1078;&#1076;&#1072;&#1103; &#1079;&#1072;&#1087;&#1080;&#1089;&#1100; ISO-2709 &#1076;&#1086;&#1083;&#1078;&#1085;&#1072; &#1089;&#1086;&#1076;&#1077;&#1088;&#1078;&#1072;&#1090;&#1100;: 
#   1) &#1052;&#1072;&#1088;&#1082;&#1077;&#1088; &#1079;&#1072;&#1087;&#1080;&#1089;&#1080;, &#1089;&#1086;&#1089;&#1090;&#1086;&#1103;&#1097;&#1080;&#1081; &#1080;&#1079; 24-&#1093; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083;&#1086;&#1074;.
#   2) &#1057;&#1087;&#1088;&#1072;&#1074;&#1086;&#1095;&#1085;&#1080;&#1082;.
#   3) &#1055;&#1086;&#1083;&#1103; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;&#1081; &#1076;&#1083;&#1080;&#1085;&#1099;, &#1086;&#1090;&#1076;&#1077;&#1083;&#1077;&#1085;&#1085;&#1099;&#1077; &#1076;&#1088;&#1091;&#1075; &#1086;&#1090; &#1076;&#1088;&#1091;&#1075;&#1072; &#1088;&#1072;&#1079;&#1076;&#1077;&#1083;&#1080;&#1090;&#1077;&#1083;&#1077;&#1084; &#1087;&#1086;&#1083;&#1103;. 
#   4) &#1056;&#1072;&#1079;&#1076;&#1077;&#1083;&#1080;&#1090;&#1077;&#1083;&#1100; &#1079;&#1072;&#1087;&#1080;&#1089;&#1080;.

#  &#1052;&#1072;&#1088;&#1082;&#1077;&#1088; &#1079;&#1072;&#1087;&#1080;&#1089;&#1080;:
#	&#1057;&#1084;&#1077;&#1097;&#1077;&#1085;&#1080;&#1077;&#1044;&#1083;&#1080;&#1085;&#1072;	&#1055;&#1086;&#1083;&#1077; 
#	(&#1073;&#1072;&#1081;&#1090;)	(&#1073;&#1072;&#1081;&#1090;)		
#	0	5	&#1044;&#1083;&#1080;&#1085;&#1072; &#1079;&#1072;&#1087;&#1080;&#1089;&#1080;
#	5	1	&#1057;&#1090;&#1072;&#1090;&#1091;&#1089; &#1079;&#1072;&#1087;&#1080;&#1089;&#1080;
#	6	4	&#1056;&#1077;&#1079;&#1077;&#1088;&#1074;
#	10	1	&#1044;&#1083;&#1080;&#1085;&#1072; &#1080;&#1085;&#1076;&#1080;&#1082;&#1072;&#1090;&#1086;&#1088;&#1072;
#	11	1	&#1044;&#1083;&#1080;&#1085;&#1072; &#1080;&#1076;&#1077;&#1085;&#1090;&#1080;&#1092;&#1080;&#1082;&#1072;&#1090;&#1086;&#1088;&#1072;
#	12	5	&#1053;&#1072;&#1095;&#1072;&#1083;&#1086; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093;
#	17	3	&#1056;&#1077;&#1079;&#1077;&#1088;&#1074;
#	20	1	&#1044;&#1083;&#1080;&#1085;&#1072;  &#1079;&#1072;&#1087;&#1080;&#1089;&#1080; &#1086; &#1076;&#1083;&#1080;&#1085;&#1077; &#1087;&#1086;&#1083;&#1103; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093;
#	21	1	&#1044;&#1083;&#1080;&#1085;&#1072; &#1079;&#1072;&#1087;&#1080;&#1089;&#1080; &#1086; &#1085;&#1072;&#1095;&#1072;&#1083;&#1100;&#1085;&#1086;&#1081; &#1087;&#1086;&#1079;&#1080;&#1094;&#1080;&#1080;
#	22	1	&#1056;&#1077;&#1079;&#1077;&#1088;&#1074;
#	23	1	&#1056;&#1077;&#1079;&#1077;&#1088;&#1074;

#  &#1057;&#1087;&#1088;&#1072;&#1074;&#1086;&#1095;&#1085;&#1080;&#1082;:
#	&#1047;&#1072; &#1084;&#1072;&#1088;&#1082;&#1077;&#1088;&#1086;&#1084; &#1079;&#1072;&#1087;&#1080;&#1089;&#1080; &#1089;&#1083;&#1077;&#1076;&#1091;&#1077;&#1090; &#1089;&#1087;&#1088;&#1072;&#1074;&#1086;&#1095;&#1085;&#1080;&#1082;. &#1050;&#1072;&#1078;&#1076;&#1072;&#1103; &#1089;&#1090;&#1072;&#1090;&#1100;&#1103; &#1089;&#1087;&#1088;&#1072;&#1074;&#1086;&#1095;&#1085;&#1080;&#1082;&#1072; &#1089;&#1086;&#1089;&#1090;&#1086;&#1080;&#1090; &#1080;&#1079; &#1090;&#1088;&#1077;&#1093; &#1095;&#1072;&#1089;&#1090;&#1077;&#1081;: 
#	1) &#1052;&#1077;&#1090;&#1082;&#1080;, &#1076;&#1083;&#1080;&#1085;&#1072; &#1082;&#1086;&#1090;&#1086;&#1088;&#1086;&#1081; &#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1103;&#1077;&#1090;&#1089;&#1103; &#1079;&#1085;&#1072;&#1095;&#1077;&#1085;&#1080;&#1077;&#1084; &#1073;&#1072;&#1081;&#1090;&#1072; 11 &#1074; &#1084;&#1072;&#1088;&#1082;&#1077;&#1088;&#1077;. (&#1055;&#1077;&#1088;&#1074;&#1072;&#1103; &#1095;&#1072;&#1089;&#1090;&#1100; &#1082;&#1072;&#1078;&#1076;&#1086;&#1081; &#1089;&#1090;&#1072;&#1090;&#1100;&#1080; &#1089;&#1087;&#1088;&#1072;&#1074;&#1086;&#1095;&#1085;&#1080;&#1082;&#1072; - &#1084;&#1077;&#1090;&#1082;&#1072; &#1087;&#1086;&#1083;&#1103;). Field tag (3 characters)
#	2) &#1063;&#1080;&#1089;&#1083;&#1072;, &#1091;&#1082;&#1072;&#1079;&#1099;&#1074;&#1072;&#1102;&#1097;&#1077;&#1075;&#1086; &#1076;&#1083;&#1080;&#1085;&#1091; &#1087;&#1086;&#1083;&#1103; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093;. &#1069;&#1090;&#1086; &#1095;&#1080;&#1089;&#1083;&#1086; &#1079;&#1072;&#1085;&#1080;&#1084;&#1072;&#1077;&#1090; &#1082;&#1086;&#1083;&#1080;&#1095;&#1077;&#1089;&#1090;&#1074;&#1086; &#1073;&#1072;&#1081;&#1090;, &#1089;&#1086;&#1086;&#1090;&#1074;&#1077;&#1090;&#1089;&#1090;&#1074;&#1091;&#1102;&#1097;&#1077;&#1077; &#1073;&#1072;&#1081;&#1090;&#1091; 20 &#1084;&#1072;&#1088;&#1082;&#1077;&#1088;&#1072;. (&#1042;&#1090;&#1086;&#1088;&#1072;&#1103; &#1095;&#1072;&#1089;&#1090;&#1100; &#1089;&#1090;&#1072;&#1090;&#1100;&#1080; &#1089;&#1087;&#1088;&#1072;&#1074;&#1086;&#1095;&#1085;&#1080;&#1082;&#1072; &#1086;&#1087;&#1088;&#1077;&#1076;&#1077;&#1083;&#1103;&#1077;&#1090; &#1095;&#1080;&#1089;&#1083;&#1086; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083;&#1086;&#1074; &#1074; &#1087;&#1086;&#1083;&#1077;, &#1085;&#1072; &#1082;&#1086;&#1090;&#1086;&#1088;&#1086;&#1077; &#1091;&#1082;&#1072;&#1079;&#1099;&#1074;&#1072;&#1077;&#1090; &#1084;&#1077;&#1090;&#1082;&#1072;, &#1087;&#1088;&#1080;&#1074;&#1077;&#1076;&#1077;&#1085;&#1085;&#1072;&#1103; &#1074; &#1087;&#1077;&#1088;&#1074;&#1086;&#1081; &#1095;&#1072;&#1089;&#1090;&#1080; &#1089;&#1090;&#1072;&#1090;&#1100;&#1080;. &#1042; &#1101;&#1090;&#1086; &#1095;&#1080;&#1089;&#1083;&#1086; &#1074;&#1082;&#1083;&#1102;&#1095;&#1072;&#1102;&#1090;&#1089;&#1103; &#1074;&#1089;&#1077; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083;&#1099; - &#1080;&#1085;&#1076;&#1080;&#1082;&#1072;&#1090;&#1086;&#1088;&#1099;, &#1080;&#1076;&#1077;&#1085;&#1090;&#1080;&#1092;&#1080;&#1082;&#1072;&#1090;&#1086;&#1088;&#1099; &#1087;&#1086;&#1076;&#1087;&#1086;&#1083;&#1077;&#1081;, &#1090;&#1077;&#1082;&#1089;&#1090;&#1086;&#1074;&#1099;&#1077; &#1080;&#1083;&#1080; &#1082;&#1086;&#1076;&#1080;&#1088;&#1086;&#1074;&#1072;&#1085;&#1085;&#1099;&#1077; &#1076;&#1072;&#1085;&#1085;&#1099;&#1077; &#1080; &#1088;&#1072;&#1079;&#1076;&#1077;&#1083;&#1080;&#1090;&#1077;&#1083;&#1100; &#1087;&#1086;&#1083;&#1077;&#1081;. ) Length of the field (4 characters)
#	3) &#1063;&#1080;&#1089;&#1083;&#1072;, &#1091;&#1082;&#1072;&#1079;&#1099;&#1074;&#1072;&#1102;&#1097;&#1077;&#1075;&#1086; &#1085;&#1072;&#1095;&#1072;&#1083;&#1100;&#1085;&#1091;&#1102; &#1087;&#1086;&#1079;&#1080;&#1094;&#1080;&#1102; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093;. &#1069;&#1090;&#1086; &#1095;&#1080;&#1089;&#1083;&#1086; &#1079;&#1072;&#1085;&#1080;&#1084;&#1072;&#1077;&#1090; &#1082;&#1086;&#1083;&#1080;&#1095;&#1077;&#1089;&#1090;&#1074;&#1086; &#1073;&#1072;&#1081;&#1090;, &#1089;&#1086;&#1086;&#1090;&#1074;&#1077;&#1090;&#1089;&#1090;&#1074;&#1091;&#1102;&#1097;&#1077;&#1077; &#1073;&#1072;&#1081;&#1090;&#1091; 21 &#1084;&#1072;&#1088;&#1082;&#1077;&#1088;&#1072;. (&#1058;&#1088;&#1077;&#1090;&#1100;&#1103; &#1095;&#1072;&#1089;&#1090;&#1100; &#1089;&#1090;&#1072;&#1090;&#1100;&#1080; &#1089;&#1087;&#1088;&#1072;&#1074;&#1086;&#1095;&#1085;&#1080;&#1082;&#1072; &#1089;&#1086;&#1076;&#1077;&#1088;&#1078;&#1080;&#1090; &#1087;&#1086;&#1079;&#1080;&#1094;&#1080;&#1102; &#1087;&#1077;&#1088;&#1074;&#1086;&#1075;&#1086; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083;&#1072; &#1087;&#1086;&#1083;&#1103; &#1086;&#1090;&#1085;&#1086;&#1089;&#1080;&#1090;&#1077;&#1083;&#1100;&#1085;&#1086; &#1087;&#1086;&#1079;&#1080;&#1094;&#1080;&#1080; &#1087;&#1077;&#1088;&#1074;&#1086;&#1075;&#1086; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083;&#1072; &#1090;&#1086;&#1081; &#1095;&#1072;&#1089;&#1090;&#1080; &#1079;&#1072;&#1087;&#1080;&#1089;&#1080;, &#1082;&#1086;&#1090;&#1086;&#1088;&#1072;&#1103; &#1089;&#1086;&#1076;&#1077;&#1088;&#1078;&#1080;&#1090; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1099;&#1077; &#1087;&#1086;&#1083;&#1103;)  tarting character position of the field (5 characters)
#  &#1044;&#1088;&#1091;&#1075;&#1080;&#1077; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083;&#1099; &#1074; &#1089;&#1090;&#1072;&#1090;&#1100;&#1077; &#1089;&#1087;&#1088;&#1072;&#1074;&#1086;&#1095;&#1085;&#1080;&#1082;&#1072; &#1085;&#1077; &#1076;&#1086;&#1087;&#1091;&#1089;&#1082;&#1072;&#1102;&#1090;&#1089;&#1103;. 
#  &#1055;&#1077;&#1088;&#1074;&#1099;&#1081; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083; &#1087;&#1077;&#1088;&#1074;&#1086;&#1075;&#1086; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;&#1075;&#1086; &#1087;&#1086;&#1083;&#1103; &#1080;&#1084;&#1077;&#1077;&#1090; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083;&#1100;&#1085;&#1091;&#1102; &#1087;&#1086;&#1079;&#1080;&#1094;&#1080;&#1102; 0. &#1055;&#1086;&#1083;&#1086;&#1078;&#1077;&#1085;&#1080;&#1077; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083;&#1100;&#1085;&#1086;&#1081; &#1087;&#1086;&#1079;&#1080;&#1094;&#1080;&#1080; 0 &#1074;&#1085;&#1091;&#1090;&#1088;&#1080; &#1094;&#1077;&#1083;&#1086;&#1081; &#1079;&#1072;&#1087;&#1080;&#1089;&#1080; &#1079;&#1072;&#1076;&#1072;&#1077;&#1090;&#1089;&#1103; &#1087;&#1086;&#1079;&#1080;&#1094;&#1080;&#1103;&#1084;&#1080; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083;&#1086;&#1074; 12-16 &#1084;&#1072;&#1088;&#1082;&#1077;&#1088;&#1072; &#1079;&#1072;&#1087;&#1080;&#1089;&#1080;. &#1057;&#1087;&#1088;&#1072;&#1074;&#1086;&#1095;&#1085;&#1080;&#1082; &#1079;&#1072;&#1082;&#1072;&#1085;&#1095;&#1080;&#1074;&#1072;&#1077;&#1090;&#1089;&#1103; &#1088;&#1072;&#1079;&#1076;&#1077;&#1083;&#1080;&#1090;&#1077;&#1083;&#1077;&#1084; &#1087;&#1086;&#1083;&#1103;. 

#  &#1055;&#1086;&#1083;&#1103; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093;
# &#1055;&#1086;&#1083;&#1103; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093; &#1087;&#1077;&#1088;&#1077;&#1084;&#1077;&#1085;&#1085;&#1086;&#1081; &#1076;&#1083;&#1080;&#1085;&#1099; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1090; &#1079;&#1072; &#1089;&#1087;&#1088;&#1072;&#1074;&#1086;&#1095;&#1085;&#1080;&#1082;&#1086;&#1084; &#1080; &#1089;&#1086;&#1076;&#1077;&#1088;&#1078;&#1072;&#1090; &#1076;&#1072;&#1085;&#1085;&#1099;&#1077;. &#1052;&#1077;&#1090;&#1082;&#1080; &#1085;&#1077; &#1089;&#1086;&#1076;&#1077;&#1088;&#1078;&#1072;&#1090;&#1100;&#1089;&#1103; &#1074; &#1087;&#1086;&#1083;&#1103;&#1093; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093;, &#1072; &#1087;&#1088;&#1080;&#1074;&#1086;&#1076;&#1103;&#1090;&#1089;&#1103; &#1090;&#1086;&#1083;&#1100;&#1082;&#1086; &#1074; &#1089;&#1087;&#1088;&#1072;&#1074;&#1086;&#1095;&#1085;&#1080;&#1082;&#1077;. &#1055;&#1086;&#1083;&#1103;  &#1076;&#1072;&#1085;&#1085;&#1099;&#1093; &#1089;&#1086;&#1089;&#1090;&#1086;&#1103;&#1090; &#1080;&#1079; &#1076;&#1074;&#1091;&#1093; &#1080;&#1085;&#1076;&#1080;&#1082;&#1072;&#1090;&#1086;&#1088;&#1086;&#1074; &#1080; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1080;&#1084; &#1079;&#1072; &#1085;&#1080;&#1084;&#1080; &#1083;&#1102;&#1073;&#1099;&#1084; &#1082;&#1086;&#1083;&#1080;&#1095;&#1077;&#1089;&#1090;&#1074;&#1086;&#1084; &#1087;&#1086;&#1076;&#1087;&#1086;&#1083;&#1077;&#1081;. &#1050;&#1072;&#1078;&#1076;&#1086;&#1077; &#1087;&#1086;&#1076;&#1087;&#1086;&#1083;&#1077; &#1085;&#1072;&#1095;&#1080;&#1085;&#1072;&#1077;&#1090;&#1089;&#1103; &#1089; &#1080;&#1076;&#1077;&#1085;&#1090;&#1080;&#1092;&#1080;&#1082;&#1072;&#1090;&#1086;&#1088;&#1072; &#1087;&#1086;&#1076;&#1087;&#1086;&#1083;&#1103;, &#1082;&#1086;&#1090;&#1086;&#1088;&#1099;&#1081; &#1089;&#1086;&#1089;&#1090;&#1086;&#1080;&#1090; &#1080;&#1079; &#1088;&#1072;&#1079;&#1076;&#1077;&#1083;&#1080;&#1090;&#1077;&#1083;&#1103; &#1087;&#1086;&#1076;&#1087;&#1086;&#1083;&#1103; &#1080; &#1082;&#1086;&#1076;&#1072; &#1087;&#1086;&#1076;&#1087;&#1086;&#1083;&#1103;, &#1080;&#1076;&#1077;&#1085;&#1090;&#1080;&#1092;&#1080;&#1094;&#1080;&#1088;&#1091;&#1102;&#1097;&#1077;&#1075;&#1086; &#1087;&#1086;&#1076;&#1087;&#1086;&#1083;&#1077;. &#1047;&#1072; &#1080;&#1076;&#1077;&#1085;&#1090;&#1080;&#1092;&#1080;&#1082;&#1072;&#1090;&#1086;&#1088;&#1072;&#1084;&#1080; &#1087;&#1086;&#1076;&#1087;&#1086;&#1083;&#1103; &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1090; &#1082;&#1086;&#1076;&#1080;&#1088;&#1086;&#1074;&#1072;&#1085;&#1085;&#1099;&#1077; &#1080;&#1083;&#1080; &#1090;&#1077;&#1082;&#1089;&#1090;&#1086;&#1074;&#1099;&#1077; &#1076;&#1072;&#1085;&#1085;&#1099;&#1077; &#1087;&#1088;&#1086;&#1080;&#1079;&#1074;&#1086;&#1083;&#1100;&#1085;&#1086;&#1081; &#1076;&#1083;&#1080;&#1085;&#1099;, &#1085;&#1077; &#1087;&#1088;&#1077;&#1074;&#1099;&#1096;&#1072;&#1102;&#1097;&#1077;&#1081; &#1091;&#1082;&#1072;&#1079;&#1072;&#1085;&#1085;&#1086;&#1081; &#1074; &#1085;&#1072;&#1095;&#1072;&#1083;&#1077; &#1086;&#1087;&#1080;&#1089;&#1072;&#1085;&#1080;&#1103; &#1087;&#1086;&#1083;&#1103;. &#1055;&#1086;&#1089;&#1083;&#1077;&#1076;&#1085;&#1080;&#1084; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083;&#1086;&#1084; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093; &#1074; &#1079;&#1072;&#1087;&#1080;&#1089;&#1080; &#1103;&#1074;&#1083;&#1103;&#1077;&#1090;&#1089;&#1103; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083; &#1082;&#1086;&#1085;&#1094;&#1072; &#1079;&#1072;&#1087;&#1080;&#1089;&#1080;, &#1089;&#1083;&#1077;&#1076;&#1091;&#1102;&#1097;&#1080;&#1081; &#1079;&#1072; &#1089;&#1080;&#1084;&#1074;&#1086;&#1083;&#1086;&#1084; &#1082;&#1086;&#1085;&#1094;&#1072; &#1087;&#1086;&#1083;&#1103;.
# &#1048;&#1085;&#1086;&#1075;&#1076;&#1072; &#1073;&#1099;&#1074;&#1072;&#1077;&#1090; &#1086;&#1095;&#1077;&#1085;&#1100; &#1087;&#1086;&#1083;&#1077;&#1079;&#1085;&#1099;&#1084; &#1079;&#1085;&#1072;&#1090;&#1100; &#1089;&#1086;&#1086;&#1090;&#1074;&#1077;&#1090;&#1089;&#1090;&#1074;&#1080;&#1077; &#1084;&#1077;&#1090;&#1086;&#1082; &#1087;&#1086;&#1083;&#1077;&#1081; &#1080; &#1087;&#1086;&#1076;&#1087;&#1086;&#1083;&#1077;&#1081; &#1086;&#1076;&#1085;&#1086;&#1075;&#1086; &#1092;&#1086;&#1088;&#1084;&#1072;&#1090;&#1072; &#1082; &#1076;&#1088;&#1091;&#1075;&#1086;&#1084;&#1091;. &#1042; &#1055;&#1088;&#1080;&#1083;&#1086;&#1078;&#1077;&#1085;&#1080;&#1080; 1. &#1087;&#1088;&#1080;&#1074;&#1077;&#1076;&#1077;&#1085;&#1086; &#1089;&#1086;&#1086;&#1090;&#1074;&#1077;&#1090;&#1089;&#1090;&#1074;&#1080;&#1077; &#1084;&#1077;&#1090;&#1086;&#1082; &#1092;&#1086;&#1088;&#1084;&#1072;&#1090;&#1072; UNIMARC &#1082; &#1092;&#1086;&#1088;&#1084;&#1072;&#1090;&#1091; USMARC, &#1072; &#1074; &#1055;&#1088;&#1080;&#1083;&#1086;&#1078;&#1077;&#1085;&#1080;&#1080; 2. &#8211; &#1085;&#1072;&#1086;&#1073;&#1086;&#1088;&#1086;&#1090;,  &#1089;&#1086;&#1086;&#1090;&#1074;&#1077;&#1090;&#1089;&#1090;&#1074;&#1080;&#1077; &#1084;&#1077;&#1090;&#1086;&#1082; &#1092;&#1086;&#1088;&#1084;&#1072;&#1090;&#1072; USMARC &#1082; &#1092;&#1086;&#1088;&#1084;&#1072;&#1090;&#1091; UNIMARC.
# &#1053;&#1080;&#1078;&#1077; &#1088;&#1072;&#1089;&#1089;&#1084;&#1072;&#1090;&#1088;&#1080;&#1074;&#1072;&#1102;&#1090;&#1089;&#1103; &#1085;&#1077;&#1082;&#1086;&#1090;&#1086;&#1088;&#1099;&#1077; &#1086;&#1089;&#1086;&#1073;&#1077;&#1085;&#1085;&#1086;&#1089;&#1090;&#1080; &#1086;&#1073;&#1097;&#1077;&#1081; &#1089;&#1093;&#1077;&#1084;&#1099; &#1086;&#1090;&#1086;&#1073;&#1088;&#1072;&#1078;&#1077;&#1085;&#1080;&#1103; &#1101;&#1083;&#1077;&#1082;&#1090;&#1088;&#1086;&#1085;&#1085;&#1099;&#1093; &#1082;&#1072;&#1090;&#1072;&#1083;&#1086;&#1075;&#1086;&#1074; &#1076;&#1083;&#1103; &#1088;&#1072;&#1073;&#1086;&#1090;&#1099; &#1087;&#1086; &#1087;&#1088;&#1086;&#1090;&#1086;&#1082;&#1086;&#1083;&#1091; Z39.50. 
# &#1055;&#1086;&#1089;&#1082;&#1086;&#1083;&#1100;&#1082;&#1091; &#1080;&#1076;&#1077;&#1086;&#1083;&#1086;&#1075;&#1080;&#1103; Z39.50 &#1087;&#1088;&#1077;&#1076;&#1087;&#1086;&#1083;&#1072;&#1075;&#1072;&#1077;&#1090; &#1086;&#1090;&#1086;&#1073;&#1088;&#1072;&#1078;&#1077;&#1085;&#1080;&#1077; &#1082;&#1086;&#1085;&#1082;&#1088;&#1077;&#1090;&#1085;&#1086;&#1081; &#1089;&#1090;&#1088;&#1091;&#1082;&#1090;&#1091;&#1088;&#1099; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093; &#1074; &#1072;&#1073;&#1089;&#1090;&#1088;&#1072;&#1082;&#1090;&#1085;&#1091;&#1102;, &#1074; &#1089;&#1086;&#1086;&#1090;&#1074;&#1077;&#1090;&#1089;&#1090;&#1074;&#1080;&#1080; &#1089; &#1080;&#1089;&#1087;&#1086;&#1083;&#1100;&#1079;&#1091;&#1077;&#1084;&#1086;&#1081; &#1089;&#1093;&#1077;&#1084;&#1086;&#1081; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093; [5], &#1086;&#1089;&#1085;&#1086;&#1074;&#1085;&#1072;&#1103; &#1079;&#1072;&#1076;&#1072;&#1095;&#1072; &#1072;&#1076;&#1072;&#1087;&#1090;&#1072;&#1094;&#1080;&#1080; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093; &#8211; &#1092;&#1086;&#1088;&#1084;&#1091;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1085;&#1080;&#1077; &#1087;&#1088;&#1072;&#1074;&#1080;&#1083; &#1090;&#1072;&#1082;&#1086;&#1075;&#1086; &#1086;&#1090;&#1086;&#1073;&#1088;&#1072;&#1078;&#1077;&#1085;&#1080;&#1103;. &#1050;&#1072;&#1082; &#1087;&#1088;&#1072;&#1074;&#1080;&#1083;&#1086;, &#1101;&#1090;&#1080;&#1084; &#1079;&#1072;&#1085;&#1080;&#1084;&#1072;&#1077;&#1090;&#1089;&#1103; &#1089;&#1086;&#1086;&#1090;&#1074;&#1077;&#1090;&#1089;&#1090;&#1074;&#1091;&#1102;&#1097;&#1080;&#1081; &#1087;&#1088;&#1086;&#1074;&#1072;&#1081;&#1076;&#1077;&#1088; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093;, &#1082;&#1086;&#1090;&#1086;&#1088;&#1099;&#1081; &#1087;&#1086;&#1079;&#1074;&#1086;&#1083;&#1103;&#1077;&#1090; &#1085;&#1077; &#1090;&#1086;&#1083;&#1100;&#1082;&#1086; &#1089;&#1092;&#1086;&#1088;&#1084;&#1091;&#1083;&#1080;&#1088;&#1086;&#1074;&#1072;&#1090;&#1100; &#1101;&#1090;&#1080; &#1087;&#1088;&#1072;&#1074;&#1080;&#1083;&#1072;, &#1085;&#1086; &#1080; &#1089;&#1085;&#1103;&#1090;&#1100; &#1088;&#1103;&#1076; &#1086;&#1075;&#1088;&#1072;&#1085;&#1080;&#1095;&#1077;&#1085;&#1080;&#1081;,  &#1085;&#1072;&#1082;&#1083;&#1072;&#1076;&#1099;&#1074;&#1072;&#1077;&#1084;&#1099;&#1093; &#1089;&#1090;&#1072;&#1085;&#1076;&#1072;&#1088;&#1090;&#1085;&#1099;&#1084; &#1087;&#1088;&#1086;&#1075;&#1088;&#1072;&#1084;&#1084;&#1085;&#1099;&#1084; &#1086;&#1073;&#1077;&#1089;&#1087;&#1077;&#1095;&#1077;&#1085;&#1080;&#1077;&#1084;. &#1058;&#1072;&#1082; &#1085;&#1072;&#1087;&#1088;&#1080;&#1084;&#1077;&#1088;, &#1087;&#1088;&#1072;&#1074;&#1080;&#1083;&#1072; &#1085;&#1072;&#1089;&#1090;&#1088;&#1086;&#1081;&#1082;&#1080; &#1089;&#1086;&#1086;&#1090;&#1074;&#1077;&#1090;&#1089;&#1090;&#1074;&#1080;&#1103; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093; &#1074;&#1099;&#1085;&#1077;&#1089;&#1077;&#1085;&#1099; &#1074; &#1086;&#1090;&#1076;&#1077;&#1083;&#1100;&#1085;&#1099;&#1077; &#1090;&#1077;&#1082;&#1089;&#1090;&#1086;&#1074;&#1099;&#1077; &#1089;&#1077;&#1088;&#1074;&#1077;&#1088;&#1085;&#1099;&#1077; &#1090;&#1072;&#1073;&#1083;&#1080;&#1094;&#1099; &#1080; &#1087;&#1088;&#1080; &#1085;&#1077;&#1086;&#1073;&#1093;&#1086;&#1076;&#1080;&#1084;&#1086;&#1089;&#1090;&#1080; &#1076;&#1086;&#1087;&#1091;&#1089;&#1082;&#1072;&#1102;&#1090; &#1080;&#1079;&#1084;&#1077;&#1085;&#1077;&#1085;&#1080;&#1103;.
# &#1042; &#1079;&#1072;&#1082;&#1083;&#1102;&#1095;&#1077;&#1085;&#1080;&#1077; &#1093;&#1086;&#1090;&#1077;&#1083;&#1086;&#1089;&#1100; &#1073;&#1099; &#1086;&#1090;&#1084;&#1077;&#1090;&#1080;&#1090;&#1100;, &#1095;&#1090;&#1086; MARC &#8211; &#1101;&#1090;&#1086; &#1083;&#1080;&#1096;&#1100; &#1092;&#1086;&#1088;&#1084;&#1072;&#1090; &#1074;&#1085;&#1077;&#1096;&#1085;&#1077;&#1075;&#1086; &#1087;&#1088;&#1077;&#1076;&#1089;&#1090;&#1072;&#1074;&#1083;&#1077;&#1085;&#1080;&#1103; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093;, &#1094;&#1077;&#1083;&#1100; &#1077;&#1075;&#1086; - &#1089;&#1083;&#1091;&#1078;&#1080;&#1090;&#1100; &#1089;&#1088;&#1077;&#1076;&#1089;&#1090;&#1074;&#1086;&#1084; &#1086;&#1073;&#1084;&#1077;&#1085;&#1072; &#1076;&#1072;&#1085;&#1085;&#1099;&#1084;&#1080;. &#1053;&#1077;&#1090; &#1085;&#1077;&#1086;&#1073;&#1093;&#1086;&#1076;&#1080;&#1084;&#1086;&#1089;&#1090;&#1080; &#1093;&#1088;&#1072;&#1085;&#1080;&#1090;&#1100; &#1076;&#1072;&#1085;&#1085;&#1099;&#1077; &#1074;&#1086; &#1074;&#1085;&#1091;&#1090;&#1088;&#1077;&#1085;&#1085;&#1077;&#1084; &#1092;&#1086;&#1088;&#1084;&#1072;&#1090;&#1077; &#1090;&#1072;&#1082;&#1086;&#1081; &#1078;&#1077; &#1089;&#1090;&#1088;&#1091;&#1082;&#1090;&#1091;&#1088;&#1099;. &#1048; &#1074;&#1089;&#1077; &#1078;&#1077;, &#1095;&#1077;&#1084; &#1073;&#1083;&#1080;&#1078;&#1077; &#1092;&#1086;&#1088;&#1084;&#1072;&#1090; &#1074;&#1074;&#1086;&#1076;&#1072; &#1080; &#1093;&#1088;&#1072;&#1085;&#1077;&#1085;&#1080;&#1103; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093; &#1082; &#1092;&#1086;&#1088;&#1084;&#1072;&#1090;&#1091; &#1086;&#1073;&#1084;&#1077;&#1085;&#1072;, &#1090;&#1077;&#1084; &#1083;&#1077;&#1075;&#1095;&#1077; &#1086;&#1089;&#1091;&#1097;&#1077;&#1089;&#1090;&#1074;&#1083;&#1103;&#1090;&#1100; &#1086;&#1076;&#1085;&#1086;&#1079;&#1085;&#1072;&#1095;&#1085;&#1099;&#1077; &#1087;&#1088;&#1077;&#1086;&#1073;&#1088;&#1072;&#1079;&#1086;&#1074;&#1072;&#1085;&#1080;&#1103; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093;. &#1055;&#1086;&#1101;&#1090;&#1086;&#1084;&#1091; &#1078;&#1077;&#1083;&#1072;&#1090;&#1077;&#1083;&#1100;&#1085;&#1086;, &#1095;&#1090;&#1086;&#1073;&#1099; &#1087;&#1088;&#1080; &#1087;&#1088;&#1086;&#1077;&#1082;&#1090;&#1080;&#1088;&#1086;&#1074;&#1072;&#1085;&#1080;&#1080; &#1089;&#1080;&#1089;&#1090;&#1077;&#1084;, &#1088;&#1072;&#1079;&#1088;&#1072;&#1073;&#1086;&#1090;&#1095;&#1080;&#1082;&#1080; &#1089;&#1090;&#1088;&#1091;&#1082;&#1090;&#1091;&#1088; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093; &#1091;&#1095;&#1080;&#1090;&#1099;&#1074;&#1072;&#1083;&#1080; &#1101;&#1090;&#1086;&#1090; &#1084;&#1086;&#1084;&#1077;&#1085;&#1090;.

# open iso-file
open(F, $iso_file) || die "$!";
binmode(F);

my $file_line;
my $real_file_size = (stat($iso_file))[7];
print "SIZE OF FILE = $real_file_size\n";
my $file_line_length; # size of file or size of real data

# read iso-file into @lines
my @lines=<F>;
close(F);

my $lines_number=scalar @lines;
my $flag_of_fixed_line_crop=0;
# determine - fixed line length or not...
if($lines_number>1)
   {if($lines[0]=~/\r\n$/)
      {if($lines[1]=~/\r\n$/)
         {if((length $lines[0])==(length $lines[1]))
            {$flag_of_fixed_line_crop=1;
             print "Found that file divided into lines with equal length: ".(length $lines[1])." \n";
            }           
         }
      }   
   if($flag_of_fixed_line_crop==0)
      {print "Found that file not divided into lines with equal length: line[0]=".(length $lines[0]).", line[1]=".(length $lines[1]).", ... \n";} 
   }
if($flag_of_fixed_line_crop==0)
   {# file, not cropped
   open(F, $iso_file) || die "$!";
   binmode(F);
   print "Readed from file ".read(F, $file_line, $real_file_size,0)." bytes\n";
   close(F);
   $file_line_length=$real_file_size;
   }
else
   {# file, cropped by lines of width length (i.e 80 chars)      
   print "Number of cropped lines: $lines_number in file $iso_file\n";
   foreach my $j(0..$lines_number-1)
      {my $line_length=length $lines[$j];
      print "LINE[$j](length $line_length)\n";
      $lines[$j]=~s/\r\n$//;
      $line_length=length $lines[$j];
      print "CROPLINE[$j](length $line_length)\n";
      }
   $file_line=join '', @lines;
   $file_line_length = length $file_line;
   print "Size of clear file data (without of cropped chars) = $file_line_length\n";
   }

#sub my_recode
 #  {
 #  my $string=decode($input_file_encoding,shift);
  # return encode($output_encoding,$string);
  # }

sub get_marker 
   {
   my ($guide) = @_ ;
   my %result = (
		# Record length (pos.0-4)
        #	0	5	&#1044;&#1083;&#1080;&#1085;&#1072; &#1079;&#1072;&#1087;&#1080;&#1089;&#1080;
      record_length_0_4 => int(substr($guide, 0, 5)),
        # Record status (pos.5)
	 	#	5	1	&#1057;&#1090;&#1072;&#1090;&#1091;&#1089; &#1079;&#1072;&#1087;&#1080;&#1089;&#1080;
      record_status_5 => substr($guide, 5, 1),	
	 	# POS.6-9 : Implementation code
		#	6	4	&#1056;&#1077;&#1079;&#1077;&#1088;&#1074;
	 # Type of record (pos.6)
      document_type_6 => substr($guide, 6, 1),
	 # Bibliographic level (pos.7)
      bibliographic_level_7 => substr($guide, 7, 1),
	 # Hierarchical level code (pos.8)
      hierarchical_level_8 => substr($guide, 8, 1), 
	 # Indicator length (pos.10, invariably 2 in UNIMARC)
	 #	10	1	&#1044;&#1083;&#1080;&#1085;&#1072; &#1080;&#1085;&#1076;&#1080;&#1082;&#1072;&#1090;&#1086;&#1088;&#1072;
      indicator_length_10 => int(substr($guide, 10, 1)),
	 # Subfield identifier length (pos.11, invariably 2 in UNIMARC)
	 #	11	1	&#1044;&#1083;&#1080;&#1085;&#1072; &#1080;&#1076;&#1077;&#1085;&#1090;&#1080;&#1092;&#1080;&#1082;&#1072;&#1090;&#1086;&#1088;&#1072;
      subfield_identifier_length_11 => int(substr($guide, 11, 1)),
	 # Base address of data (pos.12-16)
	 #	12	5	&#1053;&#1072;&#1095;&#1072;&#1083;&#1086; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093;
      base_address_12_16 => int(substr($guide, 12, 5)),
	 # POS.17-19 : Additional record definition
	 #	17	3	&#1056;&#1077;&#1079;&#1077;&#1088;&#1074;
	 # Encoding level (pos.17)
      encoding_level_17 => substr($guide, 17, 1),
	 # Descriptive cataloguing form (pos.18)
      record_update_18 => substr($guide, 18, 1),	
	 # POS.20-23 : Directory map 
	 # Length of 'Length of field' (pos.20, 4 in UNIMARC)
	 #	20	1	&#1044;&#1083;&#1080;&#1085;&#1072;  &#1079;&#1072;&#1087;&#1080;&#1089;&#1080; &#1086; &#1076;&#1083;&#1080;&#1085;&#1077; &#1087;&#1086;&#1083;&#1103; &#1076;&#1072;&#1085;&#1085;&#1099;&#1093;
      directory_1map_20 => int(substr($guide, 20, 1)),
	 # Length of 'Starting character position' (pos.21, 5 in UNIMARC)
	 #	21	1	&#1044;&#1083;&#1080;&#1085;&#1072; &#1079;&#1072;&#1087;&#1080;&#1089;&#1080; &#1086; &#1085;&#1072;&#1095;&#1072;&#1083;&#1100;&#1085;&#1086;&#1081; &#1087;&#1086;&#1079;&#1080;&#1094;&#1080;&#1080;
      directory_2map_21 => int(substr($guide, 21, 1)),
	 #	22	1	&#1056;&#1077;&#1079;&#1077;&#1088;&#1074;
	 #	23	1	&#1056;&#1077;&#1079;&#1077;&#1088;&#1074;
	 # Length of implementationdefined portion (pos.22, 0 in UNIMARC)
      directory_3map_22 => int(substr($guide, 22, 1)),
	 	# note : positions 9, 19 and 23 are undefined
	  undefined_charset_9 => substr($guide, 9, 1),
	  undefined_19 => substr($guide, 19, 1),
	  undefined_23 => substr($guide, 23, 1)
      );
   return(%result) ;
   }

my %marker_hash;

sub print_marker
   {
   print "      MARKER{record_length_0_4}=(".$marker_hash{record_length_0_4}.") {size of this record in bytes}\n";
   print "      MARKER{record_status_5}=(".$marker_hash{record_status_5}.")\n";
   print "      MARKER{document_type_6}=(".$marker_hash{document_type_6}.")\n";
   print "      MARKER{bibliographic_level_7}=(".$marker_hash{bibliographic_level_7}.")\n";
   print "      MARKER{hierarchical_level_8}=(".$marker_hash{hierarchical_level_8}.")\n";
   print "      MARKER{undefined_charset_9}=(".$marker_hash{undefined_charset_9}.")\n";
   print "      MARKER{indicator_length_10}=(".$marker_hash{indicator_length_10}.") {Subfield identifier length, invariably 2 in UNIMARC}\n";
   print "      MARKER{subfield_identifier_length_11}=(".$marker_hash{subfield_identifier_length_11}.")\n";
   print "      MARKER{base_address_12_16}=(".$marker_hash{base_address_12_16}.") {Base address of data}\n";
   print "      MARKER{encoding_level_17}=(".$marker_hash{encoding_level_17}.")\n";
   print "      MARKER{record_update_18}=(".$marker_hash{record_update_18}.") {Descriptive cataloguing form}\n";
   print "      MARKER{undefined_19}=(".$marker_hash{undefined_19}.")\n";
   print "      MARKER{directory_1map_20}=(".$marker_hash{directory_1map_20}.") {Length of 'Length of field', 4 in UNIMARC}\n";
   print "      MARKER{directory_2map_21}=(".$marker_hash{directory_2map_21}.") {Length of 'Starting character position', 5 in UNIMARC}\n";
   print "      MARKER{directory_3map_22}=(".$marker_hash{directory_3map_22}.") {Length of implementation defined portion, 0 in UNIMARC}\n";   
   print "      MARKER{undefined_23}=(".$marker_hash{undefined_23}.")\n";   
   }

sub get_directory_item 
   {
   my $directory_item = shift;
   my $field_label_length=shift;
   my $field_length_length=shift;
   my $field_address_length=shift;
   my %result = (
      # label 
      field_label =>  substr($directory_item,0,$field_label_length),
      # lentgh	
      field_length => int(substr($directory_item,$field_label_length,$field_length_length)),
      # address
      field_address => int(substr($directory_item,$field_label_length+$field_length_length,$field_address_length))
      );
   return(%result) ;
   }

sub search_subfields_delimeter
   {
   my $field=shift;
   foreach my $delimeter(@subfields_delimiter_variants)
      {
      if($field=~/$delimeter/)
         {$subfields_delimiter=$delimeter;
         print "   *Found SUBFIELDS_DELIMETER=[$subfields_delimiter]\n";
         }
      }
   #my @subfields_delimiter_variants=('\x1f','^'); # will search for this delimeters
   #my $subfields_delimiter=0; # founded delimeter will be here
   }

# two reserved variables
my %fields; # FIELDS (hash of field tags - arrays of repeatable fields - hash of subfields tags or indicators tags = array of repeatable data content of subfields or indicators)
my $marker; # MARKER (or LEADER) of record

sub extract_field_structure_ISO2709()
   {
   my $file_line=shift;
   my $record_offset=shift;
   undef %fields;
   undef $marker;
   undef %marker_hash;
   # Read first part of record - MARKER(or LEADER) - length 24 bytes
   $marker=substr($file_line,$record_offset,24);
   print "   MARKER(length=24)=[$marker]\n";
   # Extract coded data of MARKER into hash structure
   %marker_hash=&get_marker($marker);
   &print_marker();
   unless($flag_use_subfield_identifier_length)
      {$marker_hash{subfield_identifier_length_11}=$default_subfield_identifier_length;
      print "      MARKER_NEW{subfield_identifier_length}=(".$marker_hash{subfield_identifier_length_11}.")\n";
      }       
   # Read DIRECTORY (array of array of 3 values: label,length_of_label_data,start_position_of_label_data)     
   my $directory = substr($file_line, $record_offset+24, $marker_hash{base_address_12_16} - 25);
   my $directory_length=length $directory;   
   my $direcory_item_length = $marker_hash{subfield_identifier_length_11} + $marker_hash{directory_1map_20} + $marker_hash{directory_2map_21};
   my $direcory_items_number=$directory_length/$direcory_item_length;
   print "   DIRECTORY(length=$directory_length, $direcory_items_number items, $direcory_item_length bytes each)=[$directory]\n";
   #print "DIRECTORY_ITEMS[$direcory_items_number](length=$direcory_item_length)\n";   
   my $field_block_length=0;
   my @directory_array;
   my $first_field_offset;
   # Extract items of DIRECTORY array
   foreach my $k(0..$direcory_items_number-1)
      {my $direcory_item=substr($directory, $k*$direcory_item_length,$direcory_item_length);
      my %direcory_item_hash=&get_directory_item($direcory_item,$marker_hash{subfield_identifier_length_11},$marker_hash{directory_1map_20},$marker_hash{directory_2map_21});
      $field_block_length=$field_block_length+$direcory_item_hash{field_length};      
      print "      DIRECTORY_ITEM[$k]=($direcory_item): field_label=(".$direcory_item_hash{field_label}."); field_length=(".$direcory_item_hash{field_length}."); field_address=(".$direcory_item_hash{field_address}.")\n";
      if($flag_tray_correct_field_offset)
         {if($k eq 0){$first_field_offset=$direcory_item_hash{field_address}};
         $direcory_item_hash{field_address}=$direcory_item_hash{field_address}-$first_field_offset;
         if($first_field_offset>0)
            {print "      DIRECTORY_ITEM_NEW[$k]=($direcory_item): field_label=(".$direcory_item_hash{field_label}."); field_length=(".$direcory_item_hash{field_length}."); field_address=(".$direcory_item_hash{field_address}.")\n"}
         }
      push(@directory_array,{%direcory_item_hash});   
      }   
   # Find delimeter between fields block
   unless($fields_delimeter)
      {$fields_delimeter=substr($file_line, int($record_offset + 24 + $directory_length), int($marker_hash{base_address_12_16} - 24 - $directory_length));
      print "   *Found FIELDS_DELIMETER=[$fields_delimeter](char decimal number:".(ord($fields_delimeter)).")\n";
      };
   # Find delimeter at end of record (between records)
   unless($records_delimeter)
      {$records_delimeter=substr($file_line, int($record_offset + 24 + $directory_length + $field_block_length), int($marker_hash{record_length_0_4} - 24 - $directory_length - $field_block_length));
      print "   *Found RECORDS_DELIMETER=[$records_delimeter](char decimal number:".(ord($records_delimeter)).")\n";
      };
   print "   *Info: Total fields block length = $field_block_length (check: ".$marker_hash{record_length_0_4}."-24-".$directory_length."-".(length $records_delimeter)."=".int($marker_hash{record_length_0_4} - 24 - $directory_length - (length $records_delimeter)).")\n";
   # Exrtact block with fields
   my $field_block=substr($file_line, $record_offset + $marker_hash{base_address_12_16}, $field_block_length);
   #TEST#print "FIELDS_BLOCK=(".&my_recode($field_block).")\n"; # for tests if next bad
   # for each field
   foreach my $item(@directory_array)
      {my %direcory_item_hash=%{$item};
      #TEST#print "   DIRECTORY__ITEM field_label=(".$direcory_item_hash{field_label}."); field_length=(".$direcory_item_hash{field_length}."); field_address=(".$direcory_item_hash{field_address}.")\n";
      my $field_global_offset=$record_offset + $marker_hash{base_address_12_16} + $direcory_item_hash{field_address};
      my $field_size=int($direcory_item_hash{field_length} - (length $fields_delimeter));
      my $field = substr($file_line, $field_global_offset , $field_size);
      #my @repeat_field_array;
      my %sub_hash;
      if(exists $control_tags{$direcory_item_hash{field_label}})
         {# founded control field (without subfields), don't try divide into subfields
         $sub_hash{'content'}=[$field];
         #print "FIELD_CONTROL[".$direcory_item_hash{field_label}."]=(".&my_recode($sub_hash{'content'}->[0]).")\n";
	print "   FIELD_CONTROL[".$direcory_item_hash{field_label}."]{$field_global_offset..".($field_global_offset+$field_size-1).":$field_size}=(".$sub_hash{'content'}->[0].")\n";
	my $current_fields_delimeter=substr($file_line, $field_global_offset + $field_size,(length $fields_delimeter));
	unless($fields_delimeter eq $current_fields_delimeter)
	   {print "ERROR: Founded fields delimeter ($current_fields_delimeter) not equal default fileds delimeter ($fields_delimeter)! (record offset=$record_offset, control field ".$direcory_item_hash{field_label}.") EXIT.";exit;};
         }
      else # founded ordinal field (not control)
         { # Try to search subfield delimeter
         unless($subfields_delimiter){&search_subfields_delimeter($field)};
         # print whole FIELD
         my $print_field=$field; $print_field=~s/$subfields_delimiter/\^/g if (length $subfields_delimiter)>0;
         #print "FIELD[".$direcory_item_hash{field_label}."]=(".&my_recode($print_field).")\n";
	 print "   FIELD[".$direcory_item_hash{field_label}."]{$field_global_offset..".($field_global_offset+$field_size-1).":$field_size}=(".$print_field.")\n";            
         unless($field=~/$subfields_delimiter([\w\d\@])/)
            {# maybe another control tag, if yes - please add this tag to control tags ! ! !
            $sub_hash{'content'}=[$field];
            #print "      SUBFIELD[content]=(".&my_recode($sub_hash{'content'}->[0]).")\n";
            print "         SUBFIELD[content]=(".$sub_hash{'content'}->[0].")\n";
            }
         else
            {# ordinal subfield label,- like ^1, ^a, ^@...
	    # split field body into array (@parts) of subfields
	    my @parts=split(/($subfields_delimiter[\w\d\@])/,$field);
            if((not $parts[0]=~/$subfields_delimiter[\w\d\@]/) and ($parts[0] ne ""))
               {if(length $parts[0]>0)
                  {$sub_hash{'ind1'}=[substr $parts[0],0,1];
                  $sub_hash{'ind1'}=~s/\"/\&quot\;/g;
                  $sub_hash{'ind1'}=~s/\&/\&amp\;/g;
                  #print "      SUBFIELD[ind1]=(".&my_recode($sub_hash{'ind1'}->[0]).")\n";
		  print "         SUBFIELD[ind1]=(".$sub_hash{'ind1'}->[0].")\n";
                  if(length $parts[0]>1)
                     {$sub_hash{'ind2'}=[substr $parts[0],1,1];
                     $sub_hash{'ind2'}=~s/\"/\&quot\;/g;
                     $sub_hash{'ind2'}=~s/\&/\&amp\;/g;
                     #print "      SUBFIELD[ind2]=(".&my_recode($sub_hash{'ind2'}->[0]).")\n";
		     print "         SUBFIELD[ind2]=(".$sub_hash{'ind2'}->[0].")\n";
                     if(length $parts[0]>2)
                        {$sub_hash{'tail'}=[substr $parts[0],2];
                        #print "      SUBFIELD[tail]=(".&my_recode($sub_hash{'tail'}->[0]).")\n";
		        print "         SUBFIELD[tail]=(".$sub_hash{'tail'}->[0].")\n";
		        }
                     }
                  }   
               }
            foreach(my $i=0; $i<=$#parts; $i++)
               {if($parts[$i]=~/$subfields_delimiter/)
                  {my $sub_label=$parts[$i];
                  my $sub_value="";
                  if((($i+1<=$#parts) and ($parts[$i+1] ne ""))and(not $parts[$i+1]=~/$subfields_delimiter/))
                     {$sub_value=$parts[$i+1];
                     unless(exists $sub_hash{$sub_label})
                     {$sub_hash{$sub_label}=[$sub_value];
                     #print "      SUBFIELD[$sub_label]=(".&my_recode($sub_value).")\n";
		     print "         SUBFIELD[$sub_label]=(".$sub_value.")\n";
                     }
                     else
                     {push @{$sub_hash{$sub_label}},$sub_value}
                     }  
                  } 
               }   
            }
            my $current_fields_delimeter=substr($file_line, $field_global_offset + $field_size,(length $fields_delimeter));
            unless($fields_delimeter eq $current_fields_delimeter)
	      {print "\nERROR: Founded fields delimeter ($current_fields_delimeter) not equal default fileds delimeter ($fields_delimeter)! (record offset=$record_offset, control field ".$direcory_item_hash{field_label}.") EXIT.";exit;};
         }
      
      $field={%sub_hash}; # {}
      undef %sub_hash;
      #push(@repeat_field_array,$field);
      #print 'DUMP(@repeat_field_array)=((((('.&dump(@repeat_field_array).")))))\n";
      # Add collected field data to %FIELDS 
      #  (hash of field tags - arrays of repeatable fields - hash of subfields tags or indicators tags = array of repeatable data content of subfields or indicators)
      #$fields{$direcory_item_hash{field_label}}=[@repeat_field_array];       # []         
      push(@{$fields{$direcory_item_hash{field_label}}},$field);       
      #undef @repeat_field_array;
      }
   $record_offset = $record_offset + $marker_hash{record_length_0_4};
   undef %marker_hash;
   return $record_offset;
   }

# ////////
sub issubfield($$$) 
   { # &issubfield(TAG,OCC,SUBMARK)
   my $tag=shift;
   my $occ=shift;
   my $submark=shift;
   if(exists $fields{$tag})
     {my $field=$fields{$tag};
     if($field)
        {my @array=@$field;
        if(exists $array[$occ])
           {my $item=$array[$occ];
           if($item)
              {my %hash=%$item;
              if(defined $submark and $submark ne '')
                 {if(exists $hash{$submark})
                    {if($hash{$submark} ne '')
                       {my @array2=@{$hash{$submark}};
                       if(exists $array2[0])
                          {if($array2[0] ne "")
                             {return 1}
                          }
                       }
                    }
                 }else
                 {
                 if(exists $hash{'content'})
                    {if($hash{'content'} ne '')
                       {my @array2=@{$hash{'content'}};
                       if(exists $array2[0])
                          {if($array2[0] ne "")
                             {return 1}
                          }
                       }
                    }
                 }
              }
           }
        }
     } 
   return 0
   }
# \\\\\\\\

# ////////////// &print_xml_record($FILE,$number)
sub print_xml_record($$)
   {
   my $FILE=shift;
   my $number=shift;
   print $FILE ' <record';
   print $FILE ' number="'.$number.'"';
   print $FILE '>'."\n";   
   print $FILE "  <leader>$marker</leader>\n";
   #print "&PRINT_XML_RECORDS:\n";
   #print "DUMP(%fields)=(((((".dump(%fields).")))))\n";
   foreach my $label(sort keys %fields)
      {#print "(label=$label)";
      my $tag=$label; $tag='00'.$tag if (length $tag)==1; $tag='0'.$tag if (length $tag)==2;
      if(exists $control_tags{$label})
         {print $FILE "  <control tag=\"$tag\">".$fields{$label}->[0]->{content}->[0]."</control>\n";   
         }else
         {my $occ=0;
         foreach my $field(@{$fields{$label}})
            {print $FILE '  <field tag="'.$tag.'"';            
            if(&issubfield($label,$occ,'ind1'))
               {$fields{$label}->[$occ]->{'ind1'}->[0]=~s/\"/\&quot\;/g;
               print $FILE ' i1="'.$fields{$label}->[$occ]->{'ind1'}->[0].'"'}
               #else{print $FILE ' i1=""'}
            if(&issubfield($label,$occ,'ind2'))
               {$fields{$label}->[$occ]->{'ind2'}->[0]=~s/\"/\&quot\;/g;
               print $FILE ' i2="'.$fields{$label}->[$occ]->{'ind2'}->[0].'"'}
               #else{print $FILE ' i2=""'}
            print $FILE ">\n";
            foreach my $subs(sort keys %{$field})
               {if($subs=~/$subfields_delimiter/)
                  {my $code=$subs; $code=~s/$subfields_delimiter//;                  
                  foreach my $sub_item(@{$field->{$subs}})
                     {print $FILE '   <subfield code="'.$code.'">';
                     $sub_item=~s/\x{0}//gm;                 # remove chars(0)
                     $sub_item=~s/\&/\&amp;/g;
                     $sub_item=~s/\&amp;([\w\d\#]+;)/\&$1/g;
                     $sub_item=~s/\x{1e}/\x{25b2}/gm;         # 30(1eh) -> 25b2h
                     $sub_item=~s/\x{15}/\x{a7}/gm;           # 21(15h) -> a7h
                     $sub_item=~s/\</\&lt;/g;			# < 	-> &lt;
                     $sub_item=~s/\>/\&gt;/g;			# > 	-> &gt;
                     print $FILE $sub_item;
                     print $FILE "</subfield>\n";   
                     }                  
                  }
               }
            #if(&issubfield($label,$occ,'tail'))
            #   {print $FILE $fields{$label}->[$occ]->{'tail'}->[0]}
            print $FILE "  </field>\n"; 
            $occ++;
            }
         }
      }   
   print $FILE " </record>\n\n";
   }
# \\\\\\\\\\\\\\ &print_xml_record($FILE,$number)

my %used_fields_list;
sub collect_used_fields
   {
   foreach my $label(sort keys %fields)
      {my $tag=$label; $tag='00'.$tag if (length $tag)==1; $tag='0'.$tag if (length $tag)==2;
      if(exists $control_tags{$label})
         {
         if(exists $used_fields_list{$label}){$used_fields_list{$label}++}else{$used_fields_list{$label}=1}
         }else
         {my $occ=0;
         foreach my $field(@{$fields{$label}})
            {if(&issubfield($label,$occ,'ind1'))
               {$fields{$label}->[$occ]->{'ind1'}->[0]=~s/\"/\&quot\;/g;
               if(exists $used_fields_list{$label.'^ind1'}){$used_fields_list{$label.'^ind1'}++}else{$used_fields_list{$label.'^ind1'}=1}}
            if(&issubfield($label,$occ,'ind2'))
               {$fields{$label}->[$occ]->{'ind2'}->[0]=~s/\"/\&quot\;/g;
               if(exists $used_fields_list{$label.'^ind2'}){$used_fields_list{$label.'^ind2'}++}else{$used_fields_list{$label.'^ind2'}=1}}
            foreach my $subs(keys %{$field})
               {if($subs=~/$subfields_delimiter/)
                  {my $code=$subs; $code=~s/$subfields_delimiter//;
                  if(exists $used_fields_list{$label.'^'.$code}){$used_fields_list{$label.'^'.$code}++}else{$used_fields_list{$label.'^'.$code}=1}                  
                  }
               }
            if(&issubfield($label,$occ,'tail'))
               {if(exists $used_fields_list{$label.'^tail'}){$used_fields_list{$label.'^tail'}++}else{$used_fields_list{$label.'^tail'}=1}}            
            $occ++;
            }
         }
      }
   }


my $record_offset=0;
my $n=0;

# prepare output xml-file
my $xml_file=$iso_file.'.xml';
open(my $XMLFILE, ">", $xml_file) or die "Can't open $xml_file: $!";
print "FILE $xml_file opened...\n";
print $XMLFILE '<collection name="'.$iso_file.'">'."\n";                  

# read all recor from iso-file and print into xml-file
while ($record_offset<$file_line_length) 
   {
   $n++;
   print "\n\nOFFSET=$record_offset\n";
   print "RECORD[$n]:\n";
   $record_offset = &extract_field_structure_ISO2709($file_line,$record_offset); # >> %fields   
   #print CORE::dump(%fields);
   &print_xml_record($XMLFILE,$n); # << %fields
   &collect_used_fields();
   }

print $XMLFILE '</collection>';
close($XMLFILE);
print "\n\n";
print "FILE $xml_file closed.\n";

my $list_file=$iso_file.'.list.xml';
open(LIST, ">", $list_file) or die "Can't open $list_file: $!";
print LIST "<list>\n";
print LIST "   <encoding><source></source><destination>utf-8</destination></encoding>\n";
foreach my $label(sort keys %used_fields_list)
   {
   print LIST "   <label><source>$label</source><destination>$label</destination><used>".$used_fields_list{$label}."</used></label>\n";
   }
print LIST "</list>";
close(LIST);
print "FILE $list_file saved.\n";

print "Delimeters: subfields_delimiter=($subfields_delimiter); fields_delimeter=($fields_delimeter); records_delimeter=($records_delimeter)\n";
print "Total length of all records=$record_offset (check: total length of file=$file_line_length)\n";
print "Number of records: $n\n";

#my @records=split($RECORD_DELIMETER, $file_line);
#my $records_number=scalar @records;
#print "Number of records (delimeted by \"$RECORD_DELIMETER\"): $records_number\n";


